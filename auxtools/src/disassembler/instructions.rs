use crate::Proc;
use crate::StringRef;
use crate::Value;

#[derive(Debug)]
pub enum Variable {
	Null,
	World,
	Usr,
	Src,
	Args,
	Dot,
	Cache,
	Cache2,
	Cache3,
	CurrentProc,
	IndexFromStack,
	Arg(u32),
	Local(u32),
	Global(StringRef),
	Field(Box<Variable>, Vec<StringRef>),
	InitialField(Box<Variable>, Vec<StringRef>),
	StaticProcField(Box<Variable>, Vec<StringRef>, Proc),
	RuntimeProcField(Box<Variable>, Vec<StringRef>, StringRef), // TODO: Proc ones
}

#[derive(Debug)]
pub struct Call {
	pub args: ParamCount,
	pub proc: Proc,
}

#[derive(Debug)]
pub struct Switch {
	pub default: Loc,
	pub cases: Vec<(Value, Loc)>,
}

#[derive(Debug)]
pub struct PickSwitch {
	pub default: Loc,
	pub cases: Vec<(u32, Loc)>,
}

#[derive(Debug)]
pub struct SwitchRange {
	pub default: Loc,
	pub cases: Vec<(Value, Loc)>,
	pub range_cases: Vec<(Value, Value, Loc)>,
}

#[derive(Debug)]
pub struct PickProb {
	pub locs: Vec<Loc>,
}

#[derive(Debug)]
pub enum IsInOperand {
	Range,
	Value,
}

#[derive(Debug)]
pub struct ParamCount(pub u32);

pub struct Loc(pub u32);

impl std::fmt::Debug for Loc {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "{:0>4X}", self.0)
	}
}

pub struct FormatString(pub StringRef);

impl std::fmt::Debug for FormatString {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut format = vec![];

		let mut iter = self.0.data().into_iter();

		loop {
			let byte = match iter.next() {
				Some(x) => *x,
				None => break,
			};

			if byte == 0xFF {
				// NOTE: Output whitespace isn't perfect
				format.extend_from_slice(match iter.next() {
					None => break,
					Some(1) | Some(2) | Some(3) => b"[..]",
					Some(5) => b"[..]\\th",
					Some(6) => b"\\a ",
					Some(7) => b"\\A ",
					Some(8) => b"\\the ",
					Some(9) => b"\\The ",
					Some(10) => b"\\he ",
					Some(11) => b"\\He ",
					Some(12) => b"\\his ",
					Some(13) => b"\\His ",
					Some(14) => b"\\hers ",
					Some(15) => b"\\Hers ",
					Some(16) => b"\\him ",
					Some(17) => b"\\himself ",
					Some(20) => b"\\s ",
					Some(21) => b"\\proper ",
					Some(22) => b"\\improper ",
					Some(25) => b"\\underline ",
					Some(29) => b"\\font ",
					Some(30) => b"\\color ",
					Some(31) => b"\\red ",
					Some(32) => b"\\green ",
					Some(33) => b"\\blue ",
					Some(34) => b"\\black ",
					Some(35) => b"\\white ",
					Some(36) => b"\\yellow ",
					Some(37) => b"\\cyan ",
					Some(38) => b"\\magenta ",
					Some(39) => b"\\beep ",
					Some(40) => b"\\link",
					Some(42) => b"\\ref[..]",
					Some(43) => b"\\icon[..]",
					Some(44) => b"\\roman[..]",
					Some(45) => b"\\Roman[..]",
					Some(_) => b"\\unknown ",
				});
				continue;
			}

			// Escape \[] chars
			if byte == b'\\' || byte == b'[' || byte == b']' {
				format.push(b'\\');
			}

			format.push(byte);
		}

		write!(f, "Original: {:?}", self.0.data()).unwrap();
		write!(f, "Parsed: {}", String::from_utf8_lossy(&format))
	}
}

#[derive(Debug)]
pub enum Instruction {
	End(),
	New(ParamCount),
	// TODO: Pretty format the string
	Format(FormatString, ParamCount),
	Output,
	OutputFormat(FormatString, ParamCount),
	Read,
	Stat,
	Link,
	OutputFtp,
	OutputRun,
	Missile(),
	Del,
	Test,
	Not,
	Jmp(Loc),
	Jnz(),
	Jz(Loc),
	Ret,
	IsLoc,
	IsMob,
	IsObj,
	IsArea,
	IsTurf,
	Alert,
	EmptyList,
	NewList(u32),
	View,
	OView,
	ViewTarget(),
	OViewTarget(),
	Block,
	Prob,
	Rand,
	RandRange,
	Sleep,
	Spawn(Loc),
	BrowseRsc,
	IsIcon,
	Call(Variable, u32),
	CallNoReturn(Variable, u32),
	CallPath(ParamCount),
	CallParent,
	CallParentArgList,
	CallParentArgs(ParamCount),
	CallSelf,
	CallSelfArgList,
	CallSelfArgs(ParamCount),
	CallGlob(Call),
	Log10,
	Log,
	GetVar(Variable),
	SetVar(Variable),
	SetVarExpr(Variable),
	GetFlag,
	Teq,
	Tne,
	Tl,
	Tg,
	Tle,
	Tge,
	TestNotEquiv,
	UnaryNeg,
	Add,
	Sub,
	Mul,
	Div,
	Mod,
	Round,
	RoundN,
	AugAdd(Variable),
	AugSub(Variable),
	AugMul(Variable),
	AugDiv(Variable),
	AugMod(Variable),
	AugBand(Variable),
	AugBor(Variable),
	AugXor(Variable),
	AugLShift(Variable),
	AugRShift(Variable),
	PushInt(i32),
	Pop,
	IterLoad(u32, u32),
	IterNext,
	IterPush,
	IterPop,
	Roll(),
	LocatePos,
	LocateRef,
	Flick,
	Shutdown(),
	Startup(),
	RollStr,
	PushVal(Value),
	NewImage,
	PreInc(Variable),
	PostInc(Variable),
	PreDec(Variable),
	PostDec(Variable),
	Inc(Variable),
	Dec(Variable),
	Abs,
	Sqrt,
	Pow,
	Turn,
	AddText(),
	Length,
	CopyText,
	FindText,
	FindTextEx,
	CmpText,
	SortText(ParamCount),
	SortTextEx(ParamCount),
	UpperText,
	LowerText,
	Ascii2Text,
	Text2Ascii,
	Text2Num,
	Num2Text,
	Num2TextSigFigs,
	Switch(Switch),
	PickSwitch(PickSwitch),
	SwitchRange(SwitchRange),
	ListGet,
	ListSet,
	BeginListSetExpr,
	IsType,
	Band,
	Bor,
	Bxor,
	Bnot,
	LShift,
	RShift,
	DbgFile(StringRef),
	DbgLine(u32),
	Step,
	StepTo,
	StepAway,
	StepTowards,
	StepRand,
	StepSpeed,
	StepToSpeed,
	Walk,
	WalkTo,
	WalkAway,
	WalkTowards,
	WalkRand,
	GetStep,
	GetStepTo,
	GetStepAway,
	GetStepTowards,
	GetStepRand,
	GetDist,
	GetDir,
	LocateType,
	Shell,
	Text2File,
	File2Text,
	FCopy,
	IsNull,
	IsNum,
	IsText,
	StatPanel(),
	StatPanelCheck(),
	Min(ParamCount),
	Max(ParamCount),
	TypesOf(ParamCount),
	CKey,
	IsIn(IsInOperand),
	Browse(),
	BrowseOpt,
	FList,
	Index,
	JmpOr(Loc),
	JmpAnd(Loc),
	FDel,
	CallName(ParamCount),
	List2Params,
	Params2List,
	CKeyEx,
	PromptCheck,
	Rgb,
	Rgba,
	HasCall,
	HtmlEncode,
	HtmlDecode,
	Time2Text,
	Input(u32, u32, u32),
	InputColor(u32, u32, u32),
	Sin,
	Cos,
	ArcSin,
	ArcCos,
	Crash,
	NewAssocList(ParamCount),
	CallPathArgList,
	CallNameArgList, // TODO: same as above but without a src?
	CallGlobalArgList(Proc),
	NewArgList,
	MinList,
	MaxList,
	Pick,
	PickProb(PickProb),
	NewImageArgList,
	NewImageArgs(ParamCount),
	FCopyRsc,
	RandSeed,
	IconStates,
	IconNew(ParamCount),
	TurnOrFlipIcon { filter_mode: u32, var: Variable },
	IconIntensity(Variable),
	IconBlend(Variable),
	IconSwapColor(Variable),
	IconDrawBox(Variable),
	IconInsert(ParamCount),
	IconMapColors(ParamCount),
	IconScale(Variable),
	IconCrop(Variable),
	IconGetPixel(ParamCount),
	IconSize,
	ShiftIcon(Variable),
	IsFile,
	Viewers,
	OViewers,
	Hearers,
	OHearers,
	IsPath,
	IsSubPath,
	FExists,
	Jmp2(Loc),
	Jnz2(Loc),
	Jz2(Loc),
	PopN(u32),
	CheckNum,
	Range,
	Orange,
	ForRange(Loc, Variable),
	ForRangeStepSetup,
	ForRangeStep(Loc, Variable),
	UrlEncode,
	UrlDecode,
	Md5,
	Text2Path,
	WinOutput,
	WinSet,
	WinGet,
	WinClone,
	WinShow,
	IconStatesMode,
	CallLib(ParamCount),
	CallLibArgList(),
	WinExists,
	Bounds(),
	OBounds(),
	BoundsDist,
	StepAwaySpeed(),
	StepTowardsSpeed(),
	StepRandSpeed(),
	WalkSpeed(),
	WalkToSpeed(),
	WalkAwaySpeed(),
	WalkTowardsSpeed(),
	WalkRandSpeed(),
	Animate,
	NullAnimate,
	MatrixNew(ParamCount),
	Database(ParamCount),
	Try(Loc),
	Throw(),
	Catch(Loc),
	ReplaceText,
	ReplaceTextEx,
	FindLastText,
	FindLastTextEx(),
	SpanText(),
	NonSpanText(),
	SplitText,
	JoinText,
	JsonEncode,
	JsonDecode,
	RegexNew(ParamCount),
	FilterNewArgList,
	JmpIfNull(Loc),
	JmpIfNull2(Loc),
	NullCacheMaybe,
	PushToCache,
	PopFromCache,
	Tan,
	ArcTan,
	ArcTan2,
	IsList,
	Ref,
	IsMovable,
	Clamp,
	Sha1(),
	LengthChar,
	FindTextChar,
	CopyTextChar,
	ReplaceTextChar,
	ReplaceTextExChar(),
	FindLastTextChar(),
	FindLastTextExChar(),
	SpanTextChar,
	NonSpanTextChar,
	SplitTextChar(),
	Text2NumRadix,
	Num2TextRadix,
	DebugBreak,
}
